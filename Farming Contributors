"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()"""
Laser Welding Simulation for Thermoplastic Polymers
Based on: "Computer Simulation for Laser Welding of Thermoplastic Polymers" (Ho et al., 2010)

This script simulates transient heat conduction in a two-layer system (PMMA/ABS-PC)
with a moving Gaussian laser heat source.

Author: Claude
Date: October 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# MATERIAL PROPERTIES DATABASE
# ============================================================================
class Material:
    """Material properties for thermoplastic polymers"""
    def __init__(self, name, R, T, A, alpha, rho, cp, k):
        """
        Parameters:
        -----------
        name : str - Material name
        R : float - Reflectance (dimensionless)
        T : float - Transmittance (dimensionless)
        A : float - Absorptance (dimensionless)
        alpha : float - Absorption coefficient (m^-1)
        rho : float - Density (kg/m^3)
        cp : float - Specific heat capacity (J/kg·K)
        k : float - Thermal conductivity (W/m·K)
        """
        self.name = name
        self.R = R  # Reflectance
        self.T = T  # Transmittance
        self.A = A  # Absorptance
        self.alpha = alpha  # Absorption coefficient (m^-1)
        self.rho = rho  # Density (kg/m^3)
        self.cp = cp  # Specific heat (J/kg·K)
        self.k = k  # Thermal conductivity (W/m·K)
        self.thermal_diffusivity = k / (rho * cp)  # Thermal diffusivity (m^2/s)

# Material database - Easy to add new materials
MATERIALS = {
    'PMMA': Material(
        name='PMMA',
        R=0.045,      # Reflectance
        T=0.96,       # Transmittance (semi-transparent)
        A=0.0145,     # Absorptance
        alpha=6.8,    # Absorption coefficient (m^-1)
        rho=1190,     # Density (kg/m^3)
        cp=1350,      # Specific heat (J/kg·K)
        k=0.19        # Thermal conductivity (W/m·K)
    ),
    'ABS_PC': Material(
        name='ABS/PC',
        R=0.043,      # Reflectance
        T=0.06,       # Transmittance (nearly opaque)
        A=0.78,       # Absorptance
        alpha=380.1,  # Absorption coefficient (m^-1)
        rho=1060,     # Density (kg/m^3)
        cp=1330,      # Specific heat (J/kg·K)
        k=0.2         # Thermal conductivity (W/m·K)
    ),
    'Eastar_MN021_PET': Material(
        name='Eastar_MN021_PET',
        R=0.043,      # Reflectance
        T=0.84,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=100,  
        rho = 1330, 
        cp = 1330,
        k = 0.15  
    ),
    'Lexan_HPS9NEU_PC': Material(
        name='Lexan_HPS9NEU_PC',
        R=0.045,      # Reflectance
        T=0.86,       # Transmittance
        A=0.0145,     # Absorptance
        alpha=60, 
        rho = 1250,
        cp = 1250,
        k = 0.2       # Absorption coefficient (m^-1)
    ),
}
def get_Eastar_MN021_PET():
    return Material(
        name='Eastar_MN021_PET',
        density = 1330,
        specific_heat = 1330,
        thermal_conductivity = 0.18,
        absorption_coeff=100,  # m⁻¹
        reflectance=0.043,
        transmittance=0.84
    )
def get_Lexan_HPS9NEU_PC():
    return Material(
        name='Lexan_HPS9NEU_PC',
        density = 1200,
        specific_heat = 1250,
        thermal_conductivity = 0.20,
        absorption_coeff=60,  # m⁻¹
        reflectance=0.045,
        transmittance=0.86
    )

# ============================================================================
# SIMULATION PARAMETERS
# ============================================================================
class SimulationConfig:
    """Configuration for laser welding simulation"""
    def __init__(self):
        # ===== ADJUSTABLE PARAMETERS =====
        
        # Material selection
        self.top_material_name = 'Eastar_MN021_PET'
        self.bottom_material_name = 'Eastar_MN021_PET'
        
        # Layer thicknesses (m)
        self.h_top = 3.0e-3     # Top layer thickness (3 mm)
        self.h_bottom = 3.0e-3  # Bottom layer thickness (3 mm)
        
        # Laser parameters
        self.P = 100           # Laser power (W)
        self.R0 = 1.0e-3        # Laser spot radius (m) - 1 mm
        self.v = 10e-3         # Laser velocity (m/s) - 6.7 mm/s
        
        # Initial and boundary conditions
        self.T_initial = 293.15  # Initial temperature (K) - 20°C
        self.T_ambient = 293.15  # Ambient temperature (K)
        self.h_conv = 10.0       # Convection coefficient (W/m^2·K)
        
        # Computational domain
        self.L_x = 50.0e-3      # Domain length in x (m) - 50 mm
        self.nx = 200           # Number of grid points in x
        self.nz_top = 30        # Number of grid points in top layer
        self.nz_bottom = 30     # Number of grid points in bottom layer
        
        # Time parameters
        self.t_end = 6.0      # End time (s)
        self.dt = 0.05          # Time step (s)
        
        # Laser starting position
        self.x_laser_start = 0  # Laser starts at x = 10 mm
        
        # ===== DERIVED PARAMETERS =====
        self.top_material = MATERIALS[self.top_material_name]
        self.bottom_material = MATERIALS[self.bottom_material_name]
        self.h_total = self.h_top + self.h_bottom
        self.nz = self.nz_top + self.nz_bottom
        self.nt = int(self.t_end / self.dt) + 1
        
        # Grid spacing
        self.dx = self.L_x / (self.nx - 1)
        self.dz_top = self.h_top / self.nz_top
        self.dz_bottom = self.h_bottom / self.nz_bottom
        
    def print_config(self):
        """Print simulation configuration"""
        print("=" * 70)
        print("LASER WELDING SIMULATION CONFIGURATION")
        print("=" * 70)
        print(f"\nMaterials:")
        print(f"  Top layer: {self.top_material_name}")
        print(f"  Bottom layer: {self.bottom_material_name}")
        print(f"\nGeometry:")
        print(f"  Top layer thickness: {self.h_top*1e3:.2f} mm")
        print(f"  Bottom layer thickness: {self.h_bottom*1e3:.2f} mm")
        print(f"  Total thickness: {self.h_total*1e3:.2f} mm")
        print(f"  Domain length (x): {self.L_x*1e3:.2f} mm")
        print(f"\nLaser parameters:")
        print(f"  Power: {self.P} W")
        print(f"  Spot radius: {self.R0*1e3:.2f} mm")
        print(f"  Velocity: {self.v*1e3:.2f} mm/s")
        print(f"\nNumerical parameters:")
        print(f"  Grid points (x): {self.nx}")
        print(f"  Grid points (z): {self.nz} ({self.nz_top} + {self.nz_bottom})")
        print(f"  Time step: {self.dt} s")
        print(f"  Total time: {self.t_end} s")
        print(f"  Number of time steps: {self.nt}")
        print(f"  dx: {self.dx*1e6:.2f} μm")
        print(f"  dz (top): {self.dz_top*1e6:.2f} μm")
        print(f"  dz (bottom): {self.dz_bottom*1e6:.2f} μm")
        print("=" * 70 + "\n")

# ============================================================================
# LASER HEAT SOURCE
# ============================================================================
def gaussian_beam_intensity(x, x_laser, P, R0):
    """
    Calculate Gaussian beam intensity distribution (2D - along x-axis, y=0)
    
    Parameters:
    -----------
    x : array - x-position coordinates (m)
    x_laser : float - Laser center position (m)
    P : float - Laser power (W)
    R0 : float - Beam radius (m)
    
    Returns:
    --------
    I : array - Intensity (W/m^2)
    """
    r_squared = (x - x_laser)**2
    I = (P / (np.pi * R0**2)) * np.exp(-r_squared / R0**2)
    return I

def calculate_heat_source(x, z, x_laser, config):
    """
    Calculate volumetric heat source term q(x,z) for both layers
    Based on Beer-Lambert law for absorption
    
    Parameters:
    -----------
    x : array (nx,) - x coordinates (m)
    z : array (nz,) - z coordinates (m)
    x_laser : float - Current laser position (m)
    config : SimulationConfig - Simulation configuration
    
    Returns:
    --------
    q : array (nz, nx) - Volumetric heat source (W/m^3)
    """
    mat_top = config.top_material
    mat_bottom = config.bottom_material
    
    nx = len(x)
    nz = len(z)
    
    # Initialize heat source array
    q = np.zeros((nz, nx))
    
    # Surface intensity at y=0 (2D simulation along x-axis)
    I_surface = gaussian_beam_intensity(x, x_laser, config.P, config.R0)  # Shape: (nx,)
    
    # Top layer (PMMA) - semi-transparent
    # Heat source: q = (1-R) * α * I * exp(-α*z)
    for iz in range(config.nz_top):
        z_local = iz * config.dz_top  # Distance from top surface
        # Broadcasting: I_surface is (nx,), exp factor is scalar
        q[iz, :] = (1 - mat_top.R) * mat_top.alpha * I_surface * \
                   np.exp(-mat_top.alpha * z_local)
    
    # Bottom layer (ABS/PC) - nearly opaque
    # Heat source accounts for transmission through top layer
    # Intensity at interface after passing through top layer
    I_at_interface = I_surface * np.exp(-mat_top.alpha * config.h_top)  # Shape: (nx,)
    
    for iz in range(config.nz_top, nz):
        z_local = (iz - config.nz_top) * config.dz_bottom  # Distance from interface
        # Account for transmission through top layer and reflection at interface
        q[iz, :] = mat_top.T * (1 - mat_bottom.R) * mat_bottom.alpha * \
                   I_at_interface * np.exp(-mat_bottom.alpha * z_local)
    
    return q

# ============================================================================
# FINITE DIFFERENCE SOLVER
# ============================================================================
class HeatSolver:
    """Solve 2D transient heat conduction using implicit finite difference method"""
    
    def __init__(self, config):
        self.config = config
        self.setup_grid()
        
    def setup_grid(self):
        """Set up computational grid"""
        # x-direction (uniform spacing)
        self.x = np.linspace(0, self.config.L_x, self.config.nx)
        
        # z-direction (potentially non-uniform between layers)
        z_top = np.linspace(0, self.config.h_top, self.config.nz_top, endpoint=False)
        z_bottom = np.linspace(self.config.h_top, self.config.h_total, 
                              self.config.nz_bottom)
        self.z = np.concatenate([z_top, z_bottom])
        
        # Create 2D grid
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Initialize temperature field
        self.T = np.ones((self.config.nz, self.config.nx)) * self.config.T_initial
        
        # Storage for interface temperature history
        self.T_interface_history = []
        self.x_laser_history = []
        self.time_history = []
        
    def get_material_properties(self, iz):
        """Get material properties at grid point iz"""
        if iz < self.config.nz_top:
            return self.config.top_material
        else:
            return self.config.bottom_material
    
    def get_dz(self, iz):
        """Get grid spacing at point iz"""
        if iz < self.config.nz_top:
            return self.config.dz_top
        else:
            return self.config.dz_bottom
    
    def solve_timestep(self, t):
        """
        Solve one time step using implicit finite difference method
        """
        dt = self.config.dt
        dx = self.config.dx
        
        # Current laser position
        x_laser = self.config.x_laser_start + self.config.v * t
        
        # Calculate heat source - returns array of shape (nz, nx)
        q = calculate_heat_source(self.x, self.z, x_laser, self.config)
        
        # Create new temperature array
        T_new = self.T.copy()
        
        # Solve for each x-position (implicit in z-direction)
        for ix in range(self.config.nx):
            # Build tridiagonal system for this column
            N = self.config.nz
            A = lil_matrix((N, N))
            b = np.zeros(N)
            
            for iz in range(N):
                mat = self.get_material_properties(iz)
                dz = self.get_dz(iz)
                
                # Thermal diffusivity
                alpha_th = mat.k / (mat.rho * mat.cp)
                
                # Stability factors
                r_x = alpha_th * dt / dx**2
                r_z = alpha_th * dt / dz**2
                
                # Explicit treatment in x-direction
                if ix == 0 or ix == self.config.nx - 1:
                    # Boundary in x (insulated)
                    T_xx = 0
                else:
                    T_xx = (self.T[iz, ix+1] - 2*self.T[iz, ix] + self.T[iz, ix-1])
                
                # Implicit treatment in z-direction
                if iz == 0:
                    # Top surface - convective boundary
                    # -k * dT/dz = h * (T - T_ambient)
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == N - 1:
                    # Bottom surface - convective boundary
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + r_z + self.config.h_conv * dz / mat.k
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp)) + \
                           (self.config.h_conv * dz / mat.k) * self.config.T_ambient
                
                elif iz == self.config.nz_top:
                    # Interface between materials - ensure continuity
                    mat_above = self.get_material_properties(iz - 1)
                    
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
                
                else:
                    # Interior points
                    A[iz, iz-1] = -r_z
                    A[iz, iz] = 1 + 2*r_z
                    A[iz, iz+1] = -r_z
                    b[iz] = self.T[iz, ix] + r_x * T_xx + \
                           (dt * q[iz, ix] / (mat.rho * mat.cp))
            
            # Solve tridiagonal system
            A = A.tocsr()
            T_new[:, ix] = spsolve(A, b)
        
        self.T = T_new
        
        # Store interface temperature
        self.T_interface_history.append(self.T[self.config.nz_top, :].copy())
        self.x_laser_history.append(x_laser)
        self.time_history.append(t)
    
    def run_simulation(self):
        """Run full simulation"""
        print("Running simulation...")
        
        for n in range(self.config.nt):
            t = n * self.config.dt
            self.solve_timestep(t)
            
            if n % 50 == 0:
                x_laser = self.config.x_laser_start + self.config.v * t
                T_max = np.max(self.T)
                print(f"  Step {n}/{self.config.nt}, t={t:.2f}s, "
                      f"x_laser={x_laser*1e3:.2f}mm, T_max={T_max:.1f}K")
        
        print("Simulation complete!\n")

# ============================================================================
# VISUALIZATION
# ============================================================================
class Visualizer:
    """Visualization tools for simulation results"""
    
    def __init__(self, solver):
        self.solver = solver
        self.config = solver.config
    
    def plot_temperature_field(self, time_index=-1, filename='temperature_field.png'):
        """Plot 2D temperature field at a given time"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        T = self.solver.T
        
        # Convert to Celsius
        T_celsius = T - 273.15
        
        # Get dynamic range for colormap
        T_min = np.min(T_celsius)
        T_max = np.max(T_celsius)
        
        # Plot
        im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius, 
                        levels=50, cmap='hot', vmin=T_min, vmax=T_max)
        
        # Add interface line
        ax.axhline(y=self.config.h_top * 1e3, color='cyan', 
                  linestyle='--', linewidth=2, label='Interface')
        
        # Add laser position
        if time_index >= 0 and time_index < len(self.solver.x_laser_history):
            x_laser = self.solver.x_laser_history[time_index]
            ax.axvline(x=x_laser * 1e3, color='blue', 
                      linestyle='--', linewidth=2, label='Laser position')
        
        ax.set_xlabel('Position x (mm)', fontsize=12)
        ax.set_ylabel('Depth z (mm)', fontsize=12)
        
        if time_index >= 0 and time_index < len(self.solver.time_history):
            ax.set_title(f'Temperature Field at t = {self.solver.time_history[time_index]:.2f} s', 
                        fontsize=14)
        else:
            ax.set_title('Temperature Field (Final)', fontsize=14)
        
        ax.legend()
        ax.set_aspect('equal')
        
        # Set limits dynamically
        ax.set_xlim(0, self.config.L_x * 1e3)
        ax.set_ylim(0, self.config.h_total * 1e3)
        
        # Colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Temperature (°C)', fontsize=12)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_vs_position(self, time_indices=None, 
                                              filename='interface_temp_vs_position.png'):
        """
        Plot interface temperature vs position for selected times
        THIS IS THE MOST IMPORTANT GRAPH
        """
        if time_indices is None:
            # Select a few representative times
            time_indices = [len(self.solver.time_history) - 1]
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        for idx in time_indices:
            if idx >= len(self.solver.T_interface_history):
                continue
                
            T_interface = self.solver.T_interface_history[idx]
            T_celsius = T_interface - 273.15
            time = self.solver.time_history[idx]
            x_laser = self.solver.x_laser_history[idx]
            
            # Scatter plot
            ax.scatter(self.solver.x * 1e3, T_celsius, s=20, alpha=0.6,
                      label=f't = {time:.2f} s')
            
            # Mark laser position
            ax.axvline(x=x_laser * 1e3, linestyle='--', alpha=0.5, linewidth=1.5)
        
        ax.set_xlabel('Position x (mm)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature at {self.config.top_material.name}/{self.config.bottom_material.name} Interface vs Laser Position', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits based on data
        ax.set_xlim(self.solver.x.min() * 1e3, self.solver.x.max() * 1e3)
        
        # Dynamic y-limits
        T_all = np.array(self.solver.T_interface_history) - 273.15
        T_min = np.min(T_all)
        T_max = np.max(T_all)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_interface_temperature_evolution(self, x_positions=None,
                                            filename='interface_temp_evolution.png'):
        """Plot temperature evolution at specific x-positions on interface"""
        if x_positions is None:
            # Select positions: start, middle, and near the end
            x_positions = [0.02, 0.025, 0.03]  # in meters
        
        fig, ax = plt.subplots(figsize=(12, 7))
        
        times = np.array(self.solver.time_history)
        
        for x_pos in x_positions:
            # Find nearest grid point
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            x_actual = self.solver.x[ix]
            
            # Extract temperature history at this position
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            T_celsius = np.array(T_history) - 273.15
            
            ax.plot(times, T_celsius, linewidth=2, marker='o', 
                   markersize=4, label=f'x = {x_actual*1e3:.1f} mm')
        
        ax.set_xlabel('Time (s)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Interface Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_title('Temperature Evolution at Interface', fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        
        # Set limits dynamically
        ax.set_xlim(times.min(), times.max())
        
        # Calculate y-limits from all data
        all_temps = []
        for x_pos in x_positions:
            ix = np.argmin(np.abs(self.solver.x - x_pos))
            T_history = [T_int[ix] for T_int in self.solver.T_interface_history]
            all_temps.extend(np.array(T_history) - 273.15)
        
        T_min = np.min(all_temps)
        T_max = np.max(all_temps)
        margin = (T_max - T_min) * 0.1
        ax.set_ylim(T_min - margin, T_max + margin)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def plot_temperature_profiles(self, x_position=None, time_indices=None,
                                 filename='temperature_profile.png'):
        """Plot temperature profiles through thickness at given x-position"""
        if x_position is None:
            # Default: position where laser ends
            x_position = self.config.x_laser_start + self.config.v * self.config.t_end
        
        # Find nearest grid point
        ix = np.argmin(np.abs(self.solver.x - x_position))
        x_actual = self.solver.x[ix]
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # Plot current temperature profile
        T_profile = self.solver.T[:, ix] - 273.15
        ax.plot(T_profile, self.solver.z * 1e3, linewidth=2.5,
               marker='s', markersize=4, label=f't = {self.solver.time_history[-1]:.2f} s')
        
        ax.axhline(y=self.config.h_top * 1e3, color='red', linestyle='--', 
                  linewidth=2, label='Interface')
        
        ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
        ax.set_ylabel('Depth z (mm)', fontsize=14, fontweight='bold')
        ax.set_title(f'Temperature Profile at x = {x_actual*1e3:.2f} mm', 
                    fontsize=16, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.invert_yaxis()
        
        # Set limits dynamically
        T_min = np.min(T_profile)
        T_max = np.max(T_profile)
        margin = (T_max - T_min) * 0.1
        ax.set_xlim(T_min - margin, T_max + margin)
        ax.set_ylim(self.solver.z.max() * 1e3, self.solver.z.min() * 1e3)
        
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved: {filename}")
        plt.show()
    
    def create_animation(self, filename='welding_animation.gif', interval=100, step=10):
        """Create animation of temperature field evolution"""
        print("Creating animation (this may take a while)...")
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Pre-calculate temperature range for consistent colormap
        T_all = []
        for T_int in self.solver.T_interface_history[::step]:
            T_all.extend(T_int - 273.15)
        T_min_global = np.min(T_all) - 5
        T_max_global = np.max(T_all) + 10
        
        def update(frame):
            ax.clear()
            
            idx = frame * step
            if idx >= len(self.solver.T_interface_history):
                idx = len(self.solver.T_interface_history) - 1
            
            # Reconstruct approximate 2D field (simplified - using final field structure)
            T_celsius = self.solver.T - 273.15
            
            # Plot
            im = ax.contourf(self.solver.X * 1e3, self.solver.Z * 1e3, T_celsius,
                           levels=50, cmap='hot', vmin=T_min_global, vmax=T_max_global)
            
            # Add interface line
            ax.axhline(y=self.config.h_top * 1e3, color='cyan',
                      linestyle='--', linewidth=2, label='Interface')
            
            # Add laser position
            if idx < len(self.solver.x_laser_history):
                x_laser = self.solver.x_laser_history[idx]
                t = self.solver.time_history[idx]
                ax.axvline(x=x_laser * 1e3, color='blue',
                          linestyle='--', linewidth=2, label='Laser')
                ax.set_title(f'Temperature Field (t = {t:.2f} s)', fontsize=14)
            
            ax.set_xlabel('Position x (mm)', fontsize=12)
            ax.set_ylabel('Depth z (mm)', fontsize=12)
            ax.legend()
            ax.set_aspect('equal')
            ax.set_xlim(0, self.config.L_x * 1e3)
            ax.set_ylim(0, self.config.h_total * 1e3)
            
            return im,
        
        n_frames = len(self.solver.T_interface_history) // step
        anim = FuncAnimation(fig, update, frames=n_frames,
                           interval=interval, blit=False)
        
        try:
            anim.save(filename, writer='pillow', fps=10)
            print(f"Saved: {filename}")
        except Exception as e:
            print(f"Could not save animation: {e}")
            print("Make sure 'pillow' is installed: pip install pillow")
        
        plt.close()

# ============================================================================
# MAIN SIMULATION RUNNER
# ============================================================================
def main():
    """Main function to run the simulation"""
    
    print("\n" + "="*70)
    print("LASER WELDING SIMULATION FOR THERMOPLASTIC POLYMERS")
    print("Based on Ho et al. (2010)")
    print("="*70 + "\n")
    
    # Create configuration
    config = SimulationConfig()
    config.print_config()
    
    # Create solver
    solver = HeatSolver(config)
    
    # Run simulation
    solver.run_simulation()
    
    # Create visualizer
    viz = Visualizer(solver)
    
    # Generate plots
    print("Generating visualizations...\n")
    
    # 1. MOST IMPORTANT: Interface temperature vs position (scatter plot)
    viz.plot_interface_temperature_vs_position(
        time_indices=[len(solver.time_history)-1],
        filename='01_interface_temp_vs_position.png'
    )
    
    # 2. Temperature field at final time
    viz.plot_temperature_field(
        time_index=-1,
        filename='02_temperature_field_final.png'
    )
    
    # 3. Temperature evolution at specific positions
    viz.plot_interface_temperature_evolution(
        x_positions=[0.015, 0.025, 0.035],
        filename='03_interface_temp_evolution.png'
    )
    
    # 4. Temperature profile through thickness
    viz.plot_temperature_profiles(
        x_position=None,
        filename='04_temperature_profile.png'
    )
    
    # 5. Optional: Create animation (commented out by default - takes time)
    # viz.create_animation(filename='05_welding_animation.gif')
    
    # Save data
    print("\nSaving data...")
    np.savetxt('interface_temperature_data.csv',
               np.column_stack([
                   solver.x * 1e3,  # x position in mm
                   solver.T_interface_history[-1] - 273.15  # T in Celsius
               ]),
               delimiter=',',
               header='x_position_mm,interface_temperature_C',
               comments='')
    print("Saved: interface_temperature_data.csv")
    
    print("\n" + "="*70)
    print("SIMULATION COMPLETE!")
    print("="*70)
    print(f"\nMaximum interface temperature: {np.max(solver.T_interface_history[-1]) - 273.15:.1f} °C")
    print(f"Final laser position: {solver.x_laser_history[-1]*1e3:.2f} mm")
    print("\nAll plots have been saved as PNG files.")
    print("Temperature data saved to 'interface_temperature_data.csv'")
    print("="*70 + "\n")

if __name__ == "__main__":
    main()
